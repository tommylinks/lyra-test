/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace IAaveGovernanceV2 {
  export type ProposalWithoutVotesStruct = {
    id: PromiseOrValue<BigNumberish>;
    creator: PromiseOrValue<string>;
    executor: PromiseOrValue<string>;
    targets: PromiseOrValue<string>[];
    values: PromiseOrValue<BigNumberish>[];
    signatures: PromiseOrValue<string>[];
    calldatas: PromiseOrValue<BytesLike>[];
    withDelegatecalls: PromiseOrValue<boolean>[];
    startBlock: PromiseOrValue<BigNumberish>;
    endBlock: PromiseOrValue<BigNumberish>;
    executionTime: PromiseOrValue<BigNumberish>;
    forVotes: PromiseOrValue<BigNumberish>;
    againstVotes: PromiseOrValue<BigNumberish>;
    executed: PromiseOrValue<boolean>;
    canceled: PromiseOrValue<boolean>;
    strategy: PromiseOrValue<string>;
    ipfsHash: PromiseOrValue<BytesLike>;
  };

  export type ProposalWithoutVotesStructOutput = [
    BigNumber,
    string,
    string,
    string[],
    BigNumber[],
    string[],
    string[],
    boolean[],
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    boolean,
    string,
    string
  ] & {
    id: BigNumber;
    creator: string;
    executor: string;
    targets: string[];
    values: BigNumber[];
    signatures: string[];
    calldatas: string[];
    withDelegatecalls: boolean[];
    startBlock: BigNumber;
    endBlock: BigNumber;
    executionTime: BigNumber;
    forVotes: BigNumber;
    againstVotes: BigNumber;
    executed: boolean;
    canceled: boolean;
    strategy: string;
    ipfsHash: string;
  };

  export type VoteStruct = {
    support: PromiseOrValue<boolean>;
    votingPower: PromiseOrValue<BigNumberish>;
  };

  export type VoteStructOutput = [boolean, BigNumber] & {
    support: boolean;
    votingPower: BigNumber;
  };
}

export interface LyraGovernanceV2Interface extends utils.Interface {
  functions: {
    "DOMAIN_TYPEHASH()": FunctionFragment;
    "NAME()": FunctionFragment;
    "VOTE_EMITTED_TYPEHASH()": FunctionFragment;
    "__abdicate()": FunctionFragment;
    "authorizeExecutors(address[])": FunctionFragment;
    "cancel(uint256)": FunctionFragment;
    "create(address,address[],uint256[],string[],bytes[],bool[],bytes32)": FunctionFragment;
    "execute(uint256)": FunctionFragment;
    "getGovernanceStrategy()": FunctionFragment;
    "getGuardian()": FunctionFragment;
    "getProposalById(uint256)": FunctionFragment;
    "getProposalState(uint256)": FunctionFragment;
    "getProposalsCount()": FunctionFragment;
    "getVoteOnProposal(uint256,address)": FunctionFragment;
    "getVotingDelay()": FunctionFragment;
    "isExecutorAuthorized(address)": FunctionFragment;
    "owner()": FunctionFragment;
    "queue(uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setGovernanceStrategy(address)": FunctionFragment;
    "setVotingDelay(uint256)": FunctionFragment;
    "submitVote(uint256,bool)": FunctionFragment;
    "submitVoteBySignature(uint256,bool,uint8,bytes32,bytes32)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "unauthorizeExecutors(address[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DOMAIN_TYPEHASH"
      | "NAME"
      | "VOTE_EMITTED_TYPEHASH"
      | "__abdicate"
      | "authorizeExecutors"
      | "cancel"
      | "create"
      | "execute"
      | "getGovernanceStrategy"
      | "getGuardian"
      | "getProposalById"
      | "getProposalState"
      | "getProposalsCount"
      | "getVoteOnProposal"
      | "getVotingDelay"
      | "isExecutorAuthorized"
      | "owner"
      | "queue"
      | "renounceOwnership"
      | "setGovernanceStrategy"
      | "setVotingDelay"
      | "submitVote"
      | "submitVoteBySignature"
      | "transferOwnership"
      | "unauthorizeExecutors"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DOMAIN_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NAME", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "VOTE_EMITTED_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "__abdicate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "authorizeExecutors",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "cancel",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "create",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<boolean>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getGovernanceStrategy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getGuardian",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalById",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalState",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalsCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVoteOnProposal",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVotingDelay",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isExecutorAuthorized",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "queue",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setGovernanceStrategy",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setVotingDelay",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "submitVote",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "submitVoteBySignature",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "unauthorizeExecutors",
    values: [PromiseOrValue<string>[]]
  ): string;

  decodeFunctionResult(
    functionFragment: "DOMAIN_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "NAME", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "VOTE_EMITTED_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "__abdicate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "authorizeExecutors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "cancel", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getGovernanceStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getGuardian",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalById",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalsCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVoteOnProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVotingDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isExecutorAuthorized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "queue", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setGovernanceStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setVotingDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "submitVote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "submitVoteBySignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unauthorizeExecutors",
    data: BytesLike
  ): Result;

  events: {
    "ExecutorAuthorized(address)": EventFragment;
    "ExecutorUnauthorized(address)": EventFragment;
    "GovernanceStrategyChanged(address,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "ProposalCanceled(uint256)": EventFragment;
    "ProposalCreated(uint256,address,address,address[],uint256[],string[],bytes[],bool[],uint256,uint256,address,bytes32)": EventFragment;
    "ProposalExecuted(uint256,address)": EventFragment;
    "ProposalQueued(uint256,uint256,address)": EventFragment;
    "VoteEmitted(uint256,address,bool,uint256)": EventFragment;
    "VotingDelayChanged(uint256,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ExecutorAuthorized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExecutorUnauthorized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "GovernanceStrategyChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCanceled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalQueued"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VoteEmitted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VotingDelayChanged"): EventFragment;
}

export interface ExecutorAuthorizedEventObject {
  executor: string;
}
export type ExecutorAuthorizedEvent = TypedEvent<
  [string],
  ExecutorAuthorizedEventObject
>;

export type ExecutorAuthorizedEventFilter =
  TypedEventFilter<ExecutorAuthorizedEvent>;

export interface ExecutorUnauthorizedEventObject {
  executor: string;
}
export type ExecutorUnauthorizedEvent = TypedEvent<
  [string],
  ExecutorUnauthorizedEventObject
>;

export type ExecutorUnauthorizedEventFilter =
  TypedEventFilter<ExecutorUnauthorizedEvent>;

export interface GovernanceStrategyChangedEventObject {
  newStrategy: string;
  initiatorChange: string;
}
export type GovernanceStrategyChangedEvent = TypedEvent<
  [string, string],
  GovernanceStrategyChangedEventObject
>;

export type GovernanceStrategyChangedEventFilter =
  TypedEventFilter<GovernanceStrategyChangedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface ProposalCanceledEventObject {
  id: BigNumber;
}
export type ProposalCanceledEvent = TypedEvent<
  [BigNumber],
  ProposalCanceledEventObject
>;

export type ProposalCanceledEventFilter =
  TypedEventFilter<ProposalCanceledEvent>;

export interface ProposalCreatedEventObject {
  id: BigNumber;
  creator: string;
  executor: string;
  targets: string[];
  values: BigNumber[];
  signatures: string[];
  calldatas: string[];
  withDelegatecalls: boolean[];
  startBlock: BigNumber;
  endBlock: BigNumber;
  strategy: string;
  ipfsHash: string;
}
export type ProposalCreatedEvent = TypedEvent<
  [
    BigNumber,
    string,
    string,
    string[],
    BigNumber[],
    string[],
    string[],
    boolean[],
    BigNumber,
    BigNumber,
    string,
    string
  ],
  ProposalCreatedEventObject
>;

export type ProposalCreatedEventFilter = TypedEventFilter<ProposalCreatedEvent>;

export interface ProposalExecutedEventObject {
  id: BigNumber;
  initiatorExecution: string;
}
export type ProposalExecutedEvent = TypedEvent<
  [BigNumber, string],
  ProposalExecutedEventObject
>;

export type ProposalExecutedEventFilter =
  TypedEventFilter<ProposalExecutedEvent>;

export interface ProposalQueuedEventObject {
  id: BigNumber;
  executionTime: BigNumber;
  initiatorQueueing: string;
}
export type ProposalQueuedEvent = TypedEvent<
  [BigNumber, BigNumber, string],
  ProposalQueuedEventObject
>;

export type ProposalQueuedEventFilter = TypedEventFilter<ProposalQueuedEvent>;

export interface VoteEmittedEventObject {
  id: BigNumber;
  voter: string;
  support: boolean;
  votingPower: BigNumber;
}
export type VoteEmittedEvent = TypedEvent<
  [BigNumber, string, boolean, BigNumber],
  VoteEmittedEventObject
>;

export type VoteEmittedEventFilter = TypedEventFilter<VoteEmittedEvent>;

export interface VotingDelayChangedEventObject {
  newVotingDelay: BigNumber;
  initiatorChange: string;
}
export type VotingDelayChangedEvent = TypedEvent<
  [BigNumber, string],
  VotingDelayChangedEventObject
>;

export type VotingDelayChangedEventFilter =
  TypedEventFilter<VotingDelayChangedEvent>;

export interface LyraGovernanceV2 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LyraGovernanceV2Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    NAME(overrides?: CallOverrides): Promise<[string]>;

    VOTE_EMITTED_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    __abdicate(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    authorizeExecutors(
      executors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cancel(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    create(
      executor: PromiseOrValue<string>,
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      signatures: PromiseOrValue<string>[],
      calldatas: PromiseOrValue<BytesLike>[],
      withDelegatecalls: PromiseOrValue<boolean>[],
      ipfsHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getGovernanceStrategy(overrides?: CallOverrides): Promise<[string]>;

    getGuardian(overrides?: CallOverrides): Promise<[string]>;

    getProposalById(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[IAaveGovernanceV2.ProposalWithoutVotesStructOutput]>;

    getProposalState(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    getProposalsCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    getVoteOnProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[IAaveGovernanceV2.VoteStructOutput]>;

    getVotingDelay(overrides?: CallOverrides): Promise<[BigNumber]>;

    isExecutorAuthorized(
      executor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    queue(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setGovernanceStrategy(
      governanceStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setVotingDelay(
      votingDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitVote(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitVoteBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unauthorizeExecutors(
      executors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  NAME(overrides?: CallOverrides): Promise<string>;

  VOTE_EMITTED_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  __abdicate(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  authorizeExecutors(
    executors: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cancel(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  create(
    executor: PromiseOrValue<string>,
    targets: PromiseOrValue<string>[],
    values: PromiseOrValue<BigNumberish>[],
    signatures: PromiseOrValue<string>[],
    calldatas: PromiseOrValue<BytesLike>[],
    withDelegatecalls: PromiseOrValue<boolean>[],
    ipfsHash: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  execute(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getGovernanceStrategy(overrides?: CallOverrides): Promise<string>;

  getGuardian(overrides?: CallOverrides): Promise<string>;

  getProposalById(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IAaveGovernanceV2.ProposalWithoutVotesStructOutput>;

  getProposalState(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  getProposalsCount(overrides?: CallOverrides): Promise<BigNumber>;

  getVoteOnProposal(
    proposalId: PromiseOrValue<BigNumberish>,
    voter: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<IAaveGovernanceV2.VoteStructOutput>;

  getVotingDelay(overrides?: CallOverrides): Promise<BigNumber>;

  isExecutorAuthorized(
    executor: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  queue(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setGovernanceStrategy(
    governanceStrategy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setVotingDelay(
    votingDelay: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitVote(
    proposalId: PromiseOrValue<BigNumberish>,
    support: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitVoteBySignature(
    proposalId: PromiseOrValue<BigNumberish>,
    support: PromiseOrValue<boolean>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unauthorizeExecutors(
    executors: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    NAME(overrides?: CallOverrides): Promise<string>;

    VOTE_EMITTED_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    __abdicate(overrides?: CallOverrides): Promise<void>;

    authorizeExecutors(
      executors: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    cancel(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    create(
      executor: PromiseOrValue<string>,
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      signatures: PromiseOrValue<string>[],
      calldatas: PromiseOrValue<BytesLike>[],
      withDelegatecalls: PromiseOrValue<boolean>[],
      ipfsHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getGovernanceStrategy(overrides?: CallOverrides): Promise<string>;

    getGuardian(overrides?: CallOverrides): Promise<string>;

    getProposalById(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IAaveGovernanceV2.ProposalWithoutVotesStructOutput>;

    getProposalState(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    getProposalsCount(overrides?: CallOverrides): Promise<BigNumber>;

    getVoteOnProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IAaveGovernanceV2.VoteStructOutput>;

    getVotingDelay(overrides?: CallOverrides): Promise<BigNumber>;

    isExecutorAuthorized(
      executor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    queue(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setGovernanceStrategy(
      governanceStrategy: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setVotingDelay(
      votingDelay: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    submitVote(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    submitVoteBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    unauthorizeExecutors(
      executors: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ExecutorAuthorized(address)"(
      executor?: null
    ): ExecutorAuthorizedEventFilter;
    ExecutorAuthorized(executor?: null): ExecutorAuthorizedEventFilter;

    "ExecutorUnauthorized(address)"(
      executor?: null
    ): ExecutorUnauthorizedEventFilter;
    ExecutorUnauthorized(executor?: null): ExecutorUnauthorizedEventFilter;

    "GovernanceStrategyChanged(address,address)"(
      newStrategy?: PromiseOrValue<string> | null,
      initiatorChange?: PromiseOrValue<string> | null
    ): GovernanceStrategyChangedEventFilter;
    GovernanceStrategyChanged(
      newStrategy?: PromiseOrValue<string> | null,
      initiatorChange?: PromiseOrValue<string> | null
    ): GovernanceStrategyChangedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "ProposalCanceled(uint256)"(id?: null): ProposalCanceledEventFilter;
    ProposalCanceled(id?: null): ProposalCanceledEventFilter;

    "ProposalCreated(uint256,address,address,address[],uint256[],string[],bytes[],bool[],uint256,uint256,address,bytes32)"(
      id?: null,
      creator?: PromiseOrValue<string> | null,
      executor?: PromiseOrValue<string> | null,
      targets?: null,
      values?: null,
      signatures?: null,
      calldatas?: null,
      withDelegatecalls?: null,
      startBlock?: null,
      endBlock?: null,
      strategy?: null,
      ipfsHash?: null
    ): ProposalCreatedEventFilter;
    ProposalCreated(
      id?: null,
      creator?: PromiseOrValue<string> | null,
      executor?: PromiseOrValue<string> | null,
      targets?: null,
      values?: null,
      signatures?: null,
      calldatas?: null,
      withDelegatecalls?: null,
      startBlock?: null,
      endBlock?: null,
      strategy?: null,
      ipfsHash?: null
    ): ProposalCreatedEventFilter;

    "ProposalExecuted(uint256,address)"(
      id?: null,
      initiatorExecution?: PromiseOrValue<string> | null
    ): ProposalExecutedEventFilter;
    ProposalExecuted(
      id?: null,
      initiatorExecution?: PromiseOrValue<string> | null
    ): ProposalExecutedEventFilter;

    "ProposalQueued(uint256,uint256,address)"(
      id?: null,
      executionTime?: null,
      initiatorQueueing?: PromiseOrValue<string> | null
    ): ProposalQueuedEventFilter;
    ProposalQueued(
      id?: null,
      executionTime?: null,
      initiatorQueueing?: PromiseOrValue<string> | null
    ): ProposalQueuedEventFilter;

    "VoteEmitted(uint256,address,bool,uint256)"(
      id?: null,
      voter?: PromiseOrValue<string> | null,
      support?: null,
      votingPower?: null
    ): VoteEmittedEventFilter;
    VoteEmitted(
      id?: null,
      voter?: PromiseOrValue<string> | null,
      support?: null,
      votingPower?: null
    ): VoteEmittedEventFilter;

    "VotingDelayChanged(uint256,address)"(
      newVotingDelay?: null,
      initiatorChange?: PromiseOrValue<string> | null
    ): VotingDelayChangedEventFilter;
    VotingDelayChanged(
      newVotingDelay?: null,
      initiatorChange?: PromiseOrValue<string> | null
    ): VotingDelayChangedEventFilter;
  };

  estimateGas: {
    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<BigNumber>;

    VOTE_EMITTED_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    __abdicate(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    authorizeExecutors(
      executors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cancel(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    create(
      executor: PromiseOrValue<string>,
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      signatures: PromiseOrValue<string>[],
      calldatas: PromiseOrValue<BytesLike>[],
      withDelegatecalls: PromiseOrValue<boolean>[],
      ipfsHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getGovernanceStrategy(overrides?: CallOverrides): Promise<BigNumber>;

    getGuardian(overrides?: CallOverrides): Promise<BigNumber>;

    getProposalById(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProposalState(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProposalsCount(overrides?: CallOverrides): Promise<BigNumber>;

    getVoteOnProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVotingDelay(overrides?: CallOverrides): Promise<BigNumber>;

    isExecutorAuthorized(
      executor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    queue(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setGovernanceStrategy(
      governanceStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setVotingDelay(
      votingDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitVote(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitVoteBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unauthorizeExecutors(
      executors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DOMAIN_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    VOTE_EMITTED_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    __abdicate(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    authorizeExecutors(
      executors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cancel(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    create(
      executor: PromiseOrValue<string>,
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      signatures: PromiseOrValue<string>[],
      calldatas: PromiseOrValue<BytesLike>[],
      withDelegatecalls: PromiseOrValue<boolean>[],
      ipfsHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getGovernanceStrategy(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getGuardian(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getProposalById(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProposalState(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProposalsCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getVoteOnProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVotingDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isExecutorAuthorized(
      executor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    queue(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setGovernanceStrategy(
      governanceStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setVotingDelay(
      votingDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitVote(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitVoteBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unauthorizeExecutors(
      executors: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
